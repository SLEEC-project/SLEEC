/*
 * generated by Xtext 2.25.0
 */
package circus.robocalc.sleec.tests

import circus.robocalc.sleec.sLEEC.Specification
import com.google.inject.Inject
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith

@ExtendWith(InjectionExtension)
@InjectWith(SLEECInjectorProvider)
class SLEECParsingTest {
	@Inject
	ParseHelper<Specification> parseHelper
	
	@Test
	def void basic_test() {
		var result = parseHelper.parse('''
			def_start
				event e0
				event e1
			def_end
			rule_start
				Rule1 when a then b
			rule_end
		''')
		Assertions.assertNotNull(result)
	    val errors = result.eResource.errors
	    Assertions.assertTrue(errors.isEmpty,'''Unexpected errors: «errors.join(", ")»''')
	}
	
	@Test
	def void test_within() {
		var result = parseHelper.parse('''
			def_start
				event e0
				event e1
			def_end
			rule_start
				Rule1 when e0 then e1 within 2
			rule_end
		''')
		Assertions.assertNotNull(result)
	    val errors = result.eResource.errors
	    Assertions.assertTrue(errors.isEmpty,'''Unexpected errors: «errors.join(", ")»''')
	}
	
	@Test
	def void test_tigger_event() {
		var result = parseHelper.parse('''
			def_start
				event e0
				event e1
				event e2
			def_end
			rule_start
				Rule1 when e1 and e2 then e3
			rule_end
		''')
		Assertions.assertNotNull(result)
	    val errors = result.eResource.errors
	    Assertions.assertTrue(errors.isEmpty,'''Unexpected errors: «errors.join(", ")»''')
	}

	@Test
	def void test_boolean() {
		var result = parseHelper.parse('''
			def_start
				event e0
				event e1
				measure m0: boolean
			def_end
			rule_start
				Rule1 when e0 and m0 then e1
			rule_end
		''')
		Assertions.assertNotNull(result)
	    val errors = result.eResource.errors
	    Assertions.assertTrue(errors.isEmpty,'''Unexpected errors: «errors.join(", ")»''')
	}
	
	@Test
	def void test_bool_op() {
		var result = parseHelper.parse('''
			def_start
				event e0
				event e1
				measure m0: boolean
				measure m1: boolean
			def_end
			rule_start
				Rule1 when e0 and m0 or m1 then e1
				Rule2 when e0 and m0 and m1 then e1
			rule_end
		''')
		Assertions.assertNotNull(result)
	    val errors = result.eResource.errors
	    Assertions.assertTrue(errors.isEmpty,'''Unexpected errors: «errors.join(", ")»''')
	}
	
	@Test
	def void test_not_expr() {
		// rules 1 and 3 should be different and rules 1 and 2 should be the same
		var result = parseHelper.parse('''
			def_start
				event e0
				event e1
			def_end
			rule_start
				Rule1 when e0 and not m0 or m1 then e1
				Rule3 when e0 and not (m0 or m1) then e1
				Rule2 when e0 and not (m0 and not m1) then e1
			rule_end
		''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty,'''Unexpected errors: «errors.join(", ")»''')
	}
	
	@Test
	def void test_numeric() {
		var result = parseHelper.parse('''
			def_start
				event e0
				event e1
				measure m0: numeric
				measure m1: numeric
			def_end
			rule_start
				Rule1 when e0 then e1
			rule_end
		''')
		Assertions.assertNotNull(result)
	    val errors = result.eResource.errors
	    Assertions.assertTrue(errors.isEmpty,'''Unexpected errors: «errors.join(", ")»''')
	}
	
	@Test
	def void test_relop() {
		var result = parseHelper.parse('''
			def_start
				event e0
				event e1
				measure m0: numeric
				measure m1: numeric
			def_end
			rule_start
				Rule1 when e0 and m0 > m1 then e1
			rule_end
		''')
		Assertions.assertNotNull(result)
	    val errors = result.eResource.errors
	    Assertions.assertTrue(errors.isEmpty,'''Unexpected errors: «errors.join(", ")»''')
	}	
	
	@Test
	def void test_const() {
		var result = parseHelper.parse('''
			def_start
				event e0
				event e1
				measure m0: numeric
				constant c0 = 1
			def_end
			rule_start
				Rule1 when e0 and m0 > c0 then e1
				Rule2 when e0 then e1 within c0
			rule_end
		''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty,'''Unexted errors:«errors.join(", ")»''')
	}
	
	@Test
	def void test_scale() {
		var result = parseHelper.parse('''
			def_start
				measure m0: scale(s0, s1, s2)
				event e0
				event e1
			def_end
			rule_start
				Rule1 when e0 and m0 > s0 then e1
				Rule2 when e0 and m0 = s1 then e1
			rule_end
		''')
		Assertions.assertNotNull(result)
	    val errors = result.eResource.errors
	    Assertions.assertTrue(errors.isEmpty,'''Unexpected errors: «errors.join(", ")»''')
	}
	
	@Test
	def void test_precidence() {
		var result = parseHelper.parse('''
			def_start
				event e0
				event d1
			def_end
			rule_start
				Rule1 when e0 and 0 < 1 and 0 <> 0 or not 1 = 1 then e1
			rule_end
		''')
		Assertions.assertNotNull(result)
	    val errors = result.eResource.errors
	    Assertions.assertTrue(errors.isEmpty,'''Unexpected errors: «errors.join(", ")»''')
		/*
		 * check that the parse tree for the operations in rule.trigger is correct according to the grammar
		 */
	}
	
	@Test
	def void test_otherwise() {
		var result = parseHelper.parse('''
			def_start
				event e0
				event e1
				event e2
				event e3
			def_end
			rule_start
				Rule1 when e0 then e1 within 1 otherwise e2
				Rule2 when e0 then e1 within 1 otherwise e2 within 0
				Rule3 when e0 then e1 within 0 otherwise e2 within 2 unless e3
			rule_end
		''')
		Assertions.assertNotNull(result)
	    val errors = result.eResource.errors
	    Assertions.assertTrue(errors.isEmpty,'''Unexpected errors: «errors.join(", ")»''')
	}
	
	@Test
	def void test_not_response() {
		val result = parseHelper.parse('''
			def_start
				event e0
				event e1
				event e2
			def_end
			rule_start
				Rule1 when e0 then not e1 within 0
				Rule1 when e0 then e1 within 1 otherwise not e2 within 3
			rule_end
		''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty,'''Unexpeted errors: «errors.join(", ")»''')
	}
	
	@Test
	def void test_extension() {
		var result = parseHelper.parse('''
			def_start
				event e0
				event e1
				event e2
			def_end
			rule_start
				Rule1 when e0 then e1 within 1
				Rul1.a when e0 then e1 within 1 otherwise e2
			rule_end
		''')
		Assertions.assertNotNull(result)
	    val errors = result.eResource.errors
	    Assertions.assertTrue(errors.isEmpty,'''Unexpected errors: «errors.join(", ")»''')
	}
	
	@Test
	def void test_defeaters() {
		var result = parseHelper.parse('''
			def_start
				event e0
				event e1
				event e2
				measure m0: boolean
				measure m1: boolean
			def_end
			rule_start
				Rule1 when e0 then e1
					unless m0 then e2
					unless m1
			rule_end
		''')
		Assertions.assertNotNull(result)
	    val errors = result.eResource.errors
	    Assertions.assertTrue(errors.isEmpty,'''Unexpected errors: «errors.join(", ")»''')
	}
	
	@Test
	def void test_complex() {
		var result = parseHelper.parse('''
			def_start
				event e0
				event e1
				event e2
				event e3
				event e4
				event e5
				measure m0: boolean
				measure m1: numeric
				measure m2: scale(s0, s1)
				constant c0 = 5
				constant c1 = 7
			def_end
			rule_start
				Rule1 when e0 and m0 and (m1 < c0 or m2 > s0) or m1 < 5 then e1 within c0 otherwise not e2 within c1
					unless m1 <> c0 and (m0 or m1 < 5) then e3 within c1 otherwise e4 within 3 otherwise e5
			rule_end
		''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty,'''Unexpected errors:«errors.join(", ")»''')
	}
	
	@Test
	def void test_comment() {
		var result = parseHelper.parse('''
			def_start
				event e0
				event e1
			def_end
			rule_start
				// Rule1 when e0 then e2
				Rule1 when e0 then e1
			rule_end
		''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty,'''Unexpected errors:«errors.join(", ")»''')
	}
}
