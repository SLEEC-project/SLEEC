/*
 * generated by Xtext 2.25.0
 */
package circus.robocalc.sleec.validation

import circus.robocalc.sleec.sLEEC.Atom
import circus.robocalc.sleec.sLEEC.BoolComp
import circus.robocalc.sleec.sLEEC.BoolValue
import circus.robocalc.sleec.sLEEC.Boolean
import circus.robocalc.sleec.sLEEC.Constant
import circus.robocalc.sleec.sLEEC.Event
import circus.robocalc.sleec.sLEEC.MBoolExpr
import circus.robocalc.sleec.sLEEC.Measure
import circus.robocalc.sleec.sLEEC.Not
import circus.robocalc.sleec.sLEEC.Numeric
import circus.robocalc.sleec.sLEEC.RelComp
import circus.robocalc.sleec.sLEEC.SLEECPackage
import circus.robocalc.sleec.sLEEC.Scale
import circus.robocalc.sleec.sLEEC.Specification
import circus.robocalc.sleec.sLEEC.Value
import java.util.Set
import org.eclipse.xtext.validation.Check
import java.util.Map
import java.util.List

/** 
 * This class contains custom validation rules. 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class SLEECValidator extends AbstractSLEECValidator {

	@Check
	def checkEventName(Event e) {
		if (!Character.isUpperCase(e.name.charAt(0)))
			warning("Event identifier should begin with capital letter", e, SLEECPackage.Literals.DEFINITION__NAME)
	}

	@Check
	def checkMeasureName(Measure m) {
		if (!Character.isLowerCase(m.name.charAt(0)))
			warning("Measure identifier should begin with lower case letter", m, SLEECPackage.Literals.DEFINITION__NAME)
	}

	@Check
	def checkConstantName(Constant c) {
		for (i : 0 ..< c.name.length)
			if (Character.isLowerCase(c.name.charAt(i)))
				warning("Constant identifier should be in all capitals.", c, SLEECPackage.Literals.DEFINITION__NAME)
	}

	@Check
	def checkExprTypes(Specification s) {
		val defBlock = s.defBlock
		val ruleBlock = s.ruleBlock
		val Map<String, List<String>> scales = defBlock.eAllContents
			.filter(Measure)
			.filter[it.type instanceof Scale]
			.toMap([name], [(it.type as Scale).scaleParams.map[name]])
		val scaleIDs = scales.keySet
		val scaleParams = scales.values.flatten.toSet
		val booleanIDs = defBlock.eAllContents
			.filter(Measure)
			.filter[it.type instanceof Boolean]
			.map[name]
			.toSet
		val numericIDs = (defBlock.eAllContents
			.filter(Measure)
			.filter[it.type instanceof Numeric]
			.map[name] + defBlock.eAllContents
			.filter(Constant)
			.map[name]).toSet
		val IDs = numericIDs + scaleIDs + scaleParams + booleanIDs
		// check for undefined variables
		ruleBlock.eAllContents.filter(Atom).toIterable.forEach [ atom |
			if (!IDs.contains(atom.measureID))
				error("Unknown variable", atom, SLEECPackage.Literals.ATOM__MEASURE_ID)
		]

		// check the types of a relational operator
		ruleBlock.eAllContents.filter(RelComp).forEach [ relComp |
			// do nothing if both arguments are numeric
			if (isNumeric(relComp.left, numericIDs) && isNumeric(relComp.right, numericIDs))
				return;
			
			// raise an error if only one argument is numeric
			if (isNumeric(relComp.left, numericIDs) != isNumeric(relComp.right, numericIDs))
				error("Both operands must be numeric type", relComp, SLEECPackage.Literals.REL_COMP__OP)
			
			// check that both arguments are scale types
			// with one argument being a measureID and the another being a scaleParam
			if (isScaleID(relComp.left, scaleIDs) && isScaleID(relComp.right, scaleIDs) ||
				isScaleParam(relComp.left, scaleParams) && isScaleParam(relComp.right, scaleParams))
				error("One operand must be a measure and the other must be a scale", relComp, SLEECPackage.Literals.REL_COMP__OP)
				
			// check that the scale parameter matches the measure id
			val String scaleID = ((isScaleID(relComp.left, scaleIDs) ? relComp.left : relComp.right) as Atom).measureID
			val String scaleParam = ((isScaleParam(relComp.left, scaleParams) ? relComp.left : relComp.right) as Atom).measureID
			if (!scales.get(scaleID).contains(scaleParam))
				error(''''ScaleParam «scaleParam»' is not a member of MeasureID '«scaleID»'«»''', relComp, SLEECPackage.Literals.REL_COMP__OP)
		]

		// check types of comparison and not operators
		// operands can either be a boolean value or a boolean expression
		ruleBlock.eAllContents.filter(BoolComp).forEach [ boolComp |
			if (!isBoolean(boolComp.left, booleanIDs) || !isBoolean(boolComp.right, booleanIDs))
				error("Both operands must be boolean type", boolComp, SLEECPackage.Literals.BOOL_COMP__OP)

		]
		ruleBlock.eAllContents.filter(Not).forEach [ not |
			if (!isBoolean(not.expr, booleanIDs))
				error("Operand must be boolean type", not, SLEECPackage.Literals.NOT__OP)
		]

	// check for conflicts
	// create set of all variables in the system
	// find all the permutations of the variables
	// rules are redundant if there is the same response for at least 2 permuations
	}

	def private isNumeric(MBoolExpr expr, Set<String> IDs) {
		switch (expr) {
			Value: true
			Atom: IDs.contains((expr as Atom).measureID)
			default: false
		}
	}

	def private isScaleID(MBoolExpr expr, Set<String> scaleIDs) {
		expr instanceof Atom && scaleIDs.contains((expr as Atom).measureID)
	}
	
	def private isScaleParam(MBoolExpr expr, Set<String> scaleParams) {
		expr instanceof Atom && scaleParams.contains((expr as Atom).measureID)
	}

	def private isBoolean(MBoolExpr expr, Set<String> IDs) {
		switch (expr) {
			BoolValue,
			Boolean,
			Not,
			BoolComp,
			RelComp: true
			Atom: IDs.contains((expr as Atom).measureID)
			default: false
		}
	}
}
