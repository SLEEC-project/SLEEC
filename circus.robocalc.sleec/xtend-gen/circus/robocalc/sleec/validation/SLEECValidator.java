/**
 * generated by Xtext 2.25.0
 */
package circus.robocalc.sleec.validation;

import circus.robocalc.sleec.sLEEC.BoolComp;
import circus.robocalc.sleec.sLEEC.Constant;
import circus.robocalc.sleec.sLEEC.Event;
import circus.robocalc.sleec.sLEEC.MBoolExpr;
import circus.robocalc.sleec.sLEEC.Measure;
import circus.robocalc.sleec.sLEEC.Not;
import circus.robocalc.sleec.sLEEC.Numeric;
import circus.robocalc.sleec.sLEEC.RelComp;
import circus.robocalc.sleec.sLEEC.SLEECPackage;
import circus.robocalc.sleec.sLEEC.Scale;
import circus.robocalc.sleec.sLEEC.ScaleParam;
import circus.robocalc.sleec.sLEEC.Value;
import org.eclipse.xtext.validation.Check;

/**
 * This class contains custom validation rules.
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class SLEECValidator extends AbstractSLEECValidator {
  @Check
  public void checkRelCompType(final RelComp e) {
    if ((this.isScale(e.getLeft()) && this.isScale(e.getRight()))) {
      return;
    }
    if (((!this.isNumeric(e.getLeft())) || (!this.isNumeric(e.getRight())))) {
      this.error("relational operand must have numeric type.", SLEECPackage.Literals.REL_COMP__OP, "relationalOperands");
    }
  }
  
  @Check
  public void checkBoolCompType(final BoolComp e) {
    if (((!this.isBoolean(e.getLeft())) || (!this.isBoolean(e.getRight())))) {
      this.error("boolean operand must have boolean type", SLEECPackage.Literals.BOOL_COMP__OP, "booleanOperands");
    }
  }
  
  private boolean isNumeric(final MBoolExpr e) {
    return ((e instanceof Value) || 
      (e.getMeasure().getType() instanceof Numeric));
  }
  
  private boolean isBoolean(final MBoolExpr e) {
    return ((((e instanceof Not) || 
      (e instanceof BoolComp)) || 
      (e instanceof RelComp)) || 
      (e.getMeasure().getType() instanceof circus.robocalc.sleec.sLEEC.Boolean));
  }
  
  private boolean isScale(final MBoolExpr e) {
    return ((e instanceof ScaleParam) || 
      (e.getMeasure().getType() instanceof Scale));
  }
  
  @Check
  public void chechEventName(final Event e) {
    boolean _isUpperCase = Character.isUpperCase(e.getName().charAt(0));
    boolean _not = (!_isUpperCase);
    if (_not) {
      this.warning("Event identifier should begin with capital letter", SLEECPackage.Literals.DEFINITION__NAME, "invalidName");
    }
  }
  
  @Check
  public void checkMeasureName(final Measure m) {
    boolean _isLowerCase = Character.isLowerCase(m.getName().charAt(0));
    boolean _not = (!_isLowerCase);
    if (_not) {
      this.warning("Measure identifier should begin with lower case letter", SLEECPackage.Literals.DEFINITION__NAME, "invalidName");
    }
  }
  
  @Check
  public void checkContantName(final Constant c) {
    for (int i = 0; (i < c.getName().length()); i++) {
      boolean _isLowerCase = Character.isLowerCase(c.getName().charAt(i));
      if (_isLowerCase) {
        this.warning("Constant identifier should be in all capitals.", SLEECPackage.Literals.DEFINITION__NAME, "invalidName");
      }
    }
  }
}
